<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>アポイント共有アプリ</title>

    <!-- PWA Tags (Corrected) -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0284c7"/>
    <link rel="apple-touch-icon" href="icon-192.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              slate: { 50: '#f8fafc', 100: '#f1f5f9', 200: '#e2e8f0', 300: '#cbd5e1', 400: '#94a3b8', 500: '#64748b', 600: '#475569', 700: '#334155', 800: '#1e293b', 900: '#0f172a' },
              sky: { 200: '#bae6fd', 500: '#0ea5e9', 600: '#0284c7', 700: '#0369a1', 800: '#075985' },
              rose: { 100: '#ffe4e6', 500: '#f43f5e', 600: '#e11d48', 700: '#be123c' },
              green: { 100: '#dcfce7', 600: '#16a34a'}
            }
          }
        }
      }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700;900&display=swap" rel="stylesheet">
    <script>
        // Google Maps API を非同期ロード
        window.initMap = function() {
            window.googleMapsLoaded = true;
        };
    </script>
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBFw0Qbyq9zTFTd-tUY6dZWTgaQzuU17R8&libraries=places&language=ja&callback=initMap"></script>
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; }
    </style>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/japanese-holidays@1.0.10/lib/japanese-holidays.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, deleteDoc, query, orderBy, serverTimestamp, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        window.Firebase = {
            initializeApp,
            getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken,
            getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, deleteDoc, query, orderBy, serverTimestamp, setDoc
        };
    </script>

    <script type="text/babel" data-type="module">
        const { initializeApp } = window.Firebase;
        const { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } = window.Firebase;
        const { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, deleteDoc, query, orderBy, serverTimestamp, setDoc } = window.Firebase;
        const { useState, useEffect, useRef } = React;

        // --- SVG Icons ---
        const UserIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 inline-block text-gray-400" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clipRule="evenodd" /></svg>;
        const LocationIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 inline-block text-gray-400" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clipRule="evenodd" /></svg>;
        const BackIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clipRule="evenodd" /></svg>;
        const CalendarPlusIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zM5 8a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1zm1 5a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2z" clipRule="evenodd" /><path d="M13 14a1 1 0 100 2h3a1 1 0 100-2h-3z" /></svg>;
        const InfoIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 inline-block text-gray-400" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" /></svg>;
        const MapIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 inline-block" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M12 1.586l-4 4v12.828l4-4V1.586zM3.707 3.293A1 1 0 002 4v10a1 1 0 00.293.707L6 18.414V5.586L3.707 3.293zM17.707 5.293L14 1.586v12.828l2.293 2.293A1 1 0 0018 16V6a1 1 0 00-.293-.707z" clipRule="evenodd" /></svg>;
        const SettingsIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" /></svg>;

        const firebaseConfig = {
            apiKey: "AIzaSyCqT_s4-XtGBkrX590DfYRQWPEdl-kE5-0",
            authDomain: "apointo-a72bc.firebaseapp.com",
            projectId: "apointo-a72bc",
            storageBucket: "apointo-a72bc.appspot.com",
            messagingSenderId: "1014142886306",
            appId: "1:1014142886306:web:c97de02bb5f18b8af652fb",
            measurementId: "G-XWDNVF3W7V"
        };
        const appId = 'default-app-id';

        // --- Helper Functions ---
        const formatVisitTime = (startTimestamp, endTimestamp) => {
            if (!startTimestamp || !startTimestamp.seconds) return { date: '日時未設定', time: '' };
            const startDate = startTimestamp.toDate();
            const dateOptions = { year: 'numeric', month: 'long', day: 'numeric', weekday: 'short' };
            const timeOptions = { hour: '2-digit', minute: '2-digit', hour12: false };
            const dateStr = new Intl.DateTimeFormat('ja-JP', dateOptions).format(startDate);
            const startTimeStr = new Intl.DateTimeFormat('ja-JP', timeOptions).format(startDate);
            if (endTimestamp && endTimestamp.seconds) {
                const endDate = endTimestamp.toDate();
                const endTimeStr = new Intl.DateTimeFormat('ja-JP', timeOptions).format(endDate);
                return { date: dateStr, time: `${startTimeStr} - ${endTimeStr}`};
            }
            return { date: dateStr, time: startTimeStr };
        };

        const generateGoogleCalendarLink = (app) => {
            const title = `${app.customerName} 様とのアポイント`;
            const startDate = app.visitStartTimestamp.toDate();
            let endDate;
            if (app.visitEndTimestamp) {
                endDate = app.visitEndTimestamp.toDate();
            } else {
                endDate = new Date(startDate.getTime() + 60 * 60 * 1000);
            }
            const toLocalFormat = (date) => {
                const YYYY = date.getFullYear();
                const MM = ('0' + (date.getMonth() + 1)).slice(-2);
                const DD = ('0' + date.getDate()).slice(-2);
                const hh = ('0' + date.getHours()).slice(-2);
                const mm = ('0' + date.getMinutes()).slice(-2);
                const ss = ('0' + date.getSeconds()).slice(-2);
                return `${YYYY}${MM}${DD}T${hh}${mm}${ss}`;
            };
            const dates = `${toLocalFormat(startDate)}/${toLocalFormat(endDate)}`;
            const details = `目的: ${app.purpose}\n担当: ${app.salesPerson}\n連絡先: ${app.contactPerson || '未入力'}`;
            const location = app.address || '';
            const url = new URL('https://www.google.com/calendar/render');
            url.searchParams.append('action', 'TEMPLATE');
            url.searchParams.append('text', title);
            url.searchParams.append('dates', dates);
            url.searchParams.append('details', details);
            url.searchParams.append('location', location);
            url.searchParams.append('ctz', 'Asia/Tokyo');
            return url.toString();
        };

        const getDateColorClass = (date) => {
            if (window.japaneseHolidays && typeof window.japaneseHolidays.isHoliday === 'function' && window.japaneseHolidays.isHoliday(date)) {
                return 'text-rose-600';
            }
            const day = date.getDay();
            if (day === 0) return 'text-rose-600';
            if (day === 6) return 'text-sky-600';
            return 'text-slate-800';
        };

        // 週の開始日（火曜日）を取得
        const getWeekStart = (date) => {
            const d = new Date(date);
            const day = d.getDay();
            const diff = day === 0 ? -6 : 1 - day; // 火曜日を週の始まりに
            d.setDate(d.getDate() + diff + 1);
            d.setHours(0, 0, 0, 0);
            return d;
        };

        // 週の終了日（月曜日）を取得
        const getWeekEnd = (date) => {
            const start = getWeekStart(date);
            const end = new Date(start);
            end.setDate(end.getDate() + 6);
            end.setHours(23, 59, 59, 999);
            return end;
        };

        // 週の表示用フォーマット
        const formatWeekRange = (startDate) => {
            const endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 6);
            const format = (d) => `${d.getMonth() + 1}/${d.getDate()}`;
            return `${format(startDate)}(火) - ${format(endDate)}(月)`;
        };

        // --- Components ---
        const ConfirmationModal = ({ isOpen, message, onConfirm, onCancel }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4 transition-opacity">
                    <div className="bg-white rounded-xl shadow-2xl p-6 sm:p-8 max-w-sm w-full text-center transform transition-all scale-100">
                        <h3 className="text-xl font-bold text-slate-800 mb-4">重複の確認</h3>
                        <p className="text-slate-600 whitespace-pre-wrap mb-6">{message}</p>
                        <div className="flex justify-center space-x-4">
                            <button onClick={onCancel} className="w-full px-4 py-2.5 bg-slate-200 text-slate-800 font-semibold rounded-lg hover:bg-slate-300 transition focus:outline-none focus:ring-2 focus:ring-slate-400 focus:ring-offset-2">キャンセル</button>
                            <button onClick={onConfirm} className="w-full px-4 py-2.5 bg-rose-600 text-white font-semibold rounded-lg hover:bg-rose-700 transition focus:outline-none focus:ring-2 focus:ring-rose-500 focus:ring-offset-2">このまま登録</button>
                        </div>
                    </div>
                </div>
            );
        };

        // Google Maps 住所選択モーダル
        const AddressModal = ({ isOpen, onSelect, onCancel }) => {
            const mapRef = useRef(null);
            const mapInstanceRef = useRef(null);
            const autocompleteRef = useRef(null);
            const inputRef = useRef(null);
            const [mapsLoaded, setMapsLoaded] = useState(false);

            useEffect(() => {
                // Google Maps APIの読み込みを待つ
                const checkGoogleMaps = setInterval(() => {
                    if (window.google && window.google.maps) {
                        setMapsLoaded(true);
                        clearInterval(checkGoogleMaps);
                    }
                }, 100);
                return () => clearInterval(checkGoogleMaps);
            }, []);

            useEffect(() => {
                if (!isOpen || !mapRef.current || mapInstanceRef.current || !mapsLoaded) return;

                try {
                    const map = new google.maps.Map(mapRef.current, {
                    center: { lat: 35.6812, lng: 139.7671 },
                    zoom: 15,
                });
                mapInstanceRef.current = map;

                const marker = new google.maps.Marker({
                    map: map,
                    draggable: true,
                });

                const geocoder = new google.maps.Geocoder();

                const updateAddress = (location) => {
                    marker.setPosition(location);
                    map.panTo(location);
                    geocoder.geocode({ location: location }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            inputRef.current.value = results[0].formatted_address;
                        }
                    });
                };

                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition((position) => {
                        const pos = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                        };
                        updateAddress(pos);
                    });
                }

                const autocomplete = new google.maps.places.Autocomplete(inputRef.current, {
                    componentRestrictions: { country: 'jp' },
                });
                autocomplete.bindTo('bounds', map);
                autocompleteRef.current = autocomplete;

                autocomplete.addListener('place_changed', () => {
                    const place = autocomplete.getPlace();
                    if (!place.geometry || !place.geometry.location) return;
                    updateAddress(place.geometry.location);
                });

                marker.addListener('dragend', () => {
                    updateAddress(marker.getPosition());
                });

                map.addListener('click', (e) => {
                    updateAddress(e.latLng);
                });
                } catch (error) {
                    console.error('Google Maps initialization error:', error);
                }
            }, [isOpen, mapsLoaded]);

            if (!isOpen) return null;
            
            if (!mapsLoaded) {
                return (
                    <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4">
                        <div className="bg-white rounded-xl shadow-2xl p-6 max-w-md w-full text-center">
                            <p className="text-slate-600">地図を読み込んでいます...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4">
                    <div className="bg-white rounded-xl shadow-2xl p-6 max-w-2xl w-full max-h-[90vh] overflow-auto">
                        <h3 className="text-xl font-bold text-slate-800 mb-4">住所を選択</h3>
                        <input
                            ref={inputRef}
                            type="text"
                            placeholder="住所を検索..."
                            className="w-full px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 mb-4"
                        />
                        <div ref={mapRef} className="w-full h-96 rounded-lg mb-4"></div>
                        <p className="text-sm text-slate-600 mb-4">マップをクリックするか、マーカーをドラッグして位置を調整できます</p>
                        <div className="flex justify-end space-x-4">
                            <button onClick={onCancel} className="px-4 py-2 bg-slate-200 text-slate-800 font-semibold rounded-lg hover:bg-slate-300 transition">キャンセル</button>
                            <button onClick={() => onSelect(inputRef.current?.value || '')} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition">この住所を使用</button>
                        </div>
                    </div>
                </div>
            );
        };

        // 担当者管理モーダル
        const SalesPersonManagementModal = ({ isOpen, salesPeople, onAdd, onDelete, onClose }) => {
            const [newPerson, setNewPerson] = useState('');

            const handleAdd = () => {
                if (newPerson.trim()) {
                    onAdd(newPerson.trim());
                    setNewPerson('');
                }
            };

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4">
                    <div className="bg-white rounded-xl shadow-2xl p-6 max-w-md w-full max-h-[80vh] overflow-auto">
                        <h3 className="text-xl font-bold text-slate-800 mb-4">担当者管理</h3>
                        
                        <div className="mb-6">
                            <label className="block text-sm font-semibold text-slate-700 mb-2">新しい担当者を追加</label>
                            <div className="flex space-x-2">
                                <input
                                    type="text"
                                    value={newPerson}
                                    onChange={(e) => setNewPerson(e.target.value)}
                                    onKeyPress={(e) => e.key === 'Enter' && handleAdd()}
                                    placeholder="担当者名"
                                    className="flex-1 px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500"
                                />
                                <button onClick={handleAdd} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-700 transition">追加</button>
                            </div>
                        </div>

                        <div className="mb-6">
                            <label className="block text-sm font-semibold text-slate-700 mb-2">登録済み担当者</label>
                            <div className="space-y-2 max-h-64 overflow-y-auto">
                                {salesPeople.length === 0 ? (
                                    <p className="text-slate-500 text-sm">担当者が登録されていません</p>
                                ) : (
                                    salesPeople.map((person) => (
                                        <div key={person} className="flex items-center justify-between bg-slate-50 p-3 rounded-lg">
                                            <span className="font-medium text-slate-800">{person}</span>
                                            <button
                                                onClick={() => onDelete(person)}
                                                className="p-1 text-rose-500 hover:bg-rose-100 rounded transition"
                                                title="削除"
                                            >
                                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" />
                                                </svg>
                                            </button>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>

                        <div className="flex justify-end">
                            <button onClick={onClose} className="px-6 py-2 bg-slate-200 text-slate-800 font-semibold rounded-lg hover:bg-slate-300 transition">閉じる</button>
                        </div>
                    </div>
                </div>
            );
        };

        const TeamIdEntry = ({ onTeamIdSubmit }) => {
            const [inputTeamId, setInputTeamId] = useState('');
            const handleSubmit = (e) => {
                e.preventDefault();
                if (inputTeamId.trim()) onTeamIdSubmit(inputTeamId.trim());
            };
            return (
                <div className="bg-slate-100 min-h-screen flex items-center justify-center p-4">
                    <div className="w-full max-w-md bg-white rounded-2xl shadow-2xl p-8 text-center">
                        <h1 className="text-3xl font-bold text-slate-800 mb-2">ようこそ</h1>
                        <p className="text-slate-600 mb-8">チームで決めた「共有ID」を入力して開始してください。</p>
                        <form onSubmit={handleSubmit}>
                            <input type="text" value={inputTeamId} onChange={(e) => setInputTeamId(e.target.value)} className="w-full px-4 py-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition text-center text-lg shadow-inner" placeholder="例: team-okayama" required />
                            <button type="submit" className="w-full mt-6 bg-sky-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 transition-transform transform hover:scale-105 shadow-lg">アプリを開始</button>
                        </form>
                        <p className="text-xs text-slate-400 mt-8">共有IDは、チームのデータを一意に識別するためのものです。チーム全員で同じIDを使用してください。</p>
                    </div>
                </div>
            );
        };

        const AppointmentCard = ({ app, onEdit, onDelete, onViewDetails, isDetailPage = false, isPast = false }) => {
            const { date, time } = formatVisitTime(app.visitStartTimestamp, app.visitEndTimestamp);
            const dateColorClass = getDateColorClass(app.visitStartTimestamp.toDate());
            
            const handleAddToCalendar = (e) => {
                e.stopPropagation();
                const url = generateGoogleCalendarLink(app);
                window.open(url, '_blank', 'noopener,noreferrer');
            };

            return (
                <div className={`bg-white border border-slate-200 p-5 rounded-xl shadow-sm transition-shadow duration-300 ${!isPast && 'hover:shadow-lg'}`}>
                    <div className="flex justify-between items-start">
                        <div>
                            {(!isDetailPage || isPast) && <p className={`font-semibold ${isPast ? dateColorClass.replace('slate-800', 'slate-500').replace('sky-600', 'sky-500').replace('rose-600', 'rose-500') : dateColorClass}`}>{date}</p>}
                            <p className={`text-2xl font-bold mt-1 ${isPast ? 'text-slate-500' : 'text-slate-800'}`}>{time}</p>
                        </div>
                        <div className="flex space-x-1">
                            <button onClick={handleAddToCalendar} title="Googleカレンダーに追加" className="p-2 text-green-600 hover:bg-green-100 rounded-full transition"><CalendarPlusIcon /></button>
                            <button onClick={() => onEdit(app)} title="編集" className="p-2 text-slate-500 hover:bg-slate-100 rounded-full transition"><svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fillRule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clipRule="evenodd" /></svg></button>
                            <button onClick={() => onDelete(app.id)} title="削除" className="p-2 text-rose-500 hover:bg-rose-100 rounded-full transition"><svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg></button>
                        </div>
                    </div>
                    <div className="mt-4 pt-4 border-t border-slate-200">
                        <h3 className={`text-lg font-bold ${isPast ? 'text-slate-600' : 'text-slate-800'}`}>{app.customerName} 様</h3>
                        {app.address && <p className="text-slate-600 text-sm mt-1 flex items-center"><LocationIcon />{app.address}</p>}
                        {app.contactPerson && <p className="text-slate-600 text-sm mt-1 flex items-center"><InfoIcon />{app.contactPerson}</p>}
                        <p className="mt-3 text-sm text-slate-700 bg-slate-100 p-3 rounded-md whitespace-pre-wrap">{app.purpose}</p>
                    </div>
                    {!isDetailPage && !isPast && (
                        <div className="mt-4 flex justify-between items-center">
                            <span className="text-sm font-medium text-slate-500 flex items-center"><UserIcon />担当: {app.salesPerson}</span>
                            <button onClick={() => onViewDetails(app.salesPerson)} className="text-sm font-semibold text-sky-600 hover:text-sky-800 transition">詳細を見る →</button>
                        </div>
                    )}
                </div>
            );
        };

        const DetailPage = ({ salesPerson, appointments, onBack, onEdit, onDelete, onViewPast, onViewWeekly }) => {
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            
            const personAppointments = appointments
                .filter(app => app.salesPerson === salesPerson && app.visitStartTimestamp.toDate() > oneHourAgo)
                .sort((a, b) => a.visitStartTimestamp.seconds - b.visitStartTimestamp.seconds);

            const groupedAppointments = personAppointments.reduce((acc, app) => {
                const jsDate = app.visitStartTimestamp.toDate();
                const year = jsDate.getFullYear();
                const month = ('0' + (jsDate.getMonth() + 1)).slice(-2);
                const day = ('0' + jsDate.getDate()).slice(-2);
                const dateKey = `${year}-${month}-${day}`;
                if (!acc[dateKey]) acc[dateKey] = [];
                acc[dateKey].push(app);
                return acc;
            }, {});

            const sortedDates = Object.keys(groupedAppointments).sort();

            return (
                <div className="container mx-auto p-4 sm:p-6 lg:p-8">
                    <header className="mb-8">
                        <div className="flex justify-between items-center">
                            <button onClick={onBack} className="flex items-center text-slate-600 hover:text-slate-900 font-semibold transition mb-4">
                                <BackIcon />
                                一覧に戻る
                            </button>
                            <div className="flex space-x-2 mb-4">
                                <button onClick={onViewWeekly} className="text-sm font-semibold text-green-600 hover:text-green-800 transition">
                                    週間表示 →
                                </button>
                                <button onClick={onViewPast} className="text-sm font-semibold text-sky-600 hover:text-sky-800 transition">
                                    過去のアポ →
                                </button>
                            </div>
                        </div>
                        <h1 className="text-3xl sm:text-4xl font-bold text-slate-800">{salesPerson}さんのアポイント</h1>
                        <p className="text-slate-500 mt-2">{personAppointments.length}件の今後の予定があります</p>
                    </header>
                    <main>
                        {sortedDates.length > 0 ? (
                            <div className="space-y-8">
                                {sortedDates.map(date => {
                                    const dateObj = new Date(date + 'T00:00:00');
                                    const dateOptions = { month: 'long', day: 'numeric', weekday: 'long' };
                                    const formattedDate = new Intl.DateTimeFormat('ja-JP', dateOptions).format(dateObj);
                                    const count = groupedAppointments[date].length;
                                    const dateColorClass = getDateColorClass(dateObj);
                                    return (
                                        <section key={date}>
                                            <h2 className={`text-xl font-bold mb-4 pb-2 border-b-2 border-sky-200 ${dateColorClass}`}>
                                                {formattedDate}
                                                <span className="text-base font-medium text-slate-500 ml-3">({count}件)</span>
                                            </h2>
                                            <div className="space-y-5">
                                                {groupedAppointments[date].map(app => (
                                                    <AppointmentCard key={app.id} app={app} onEdit={onEdit} onDelete={onDelete} isDetailPage={true} />
                                                ))}
                                            </div>
                                        </section>
                                    );
                                })}
                            </div>
                        ) : (
                            <div className="text-center py-16 bg-white rounded-xl shadow-sm">
                                <p className="text-slate-500">今後のアポイントはありません。</p>
                            </div>
                        )}
                    </main>
                </div>
            );
        };
        
        // 週間表示ページ
        const WeeklyViewPage = ({ salesPerson, appointments, onBack, onEdit, onDelete }) => {
            const [currentWeekStart, setCurrentWeekStart] = useState(() => getWeekStart(new Date()));

            const weekEnd = getWeekEnd(currentWeekStart);
            
            const weekAppointments = appointments
                .filter(app => {
                    if (app.salesPerson !== salesPerson) return false;
                    const appDate = app.visitStartTimestamp.toDate();
                    return appDate >= currentWeekStart && appDate <= weekEnd;
                })
                .sort((a, b) => a.visitStartTimestamp.seconds - b.visitStartTimestamp.seconds);

            const groupedByDay = weekAppointments.reduce((acc, app) => {
                const jsDate = app.visitStartTimestamp.toDate();
                const dateKey = jsDate.toISOString().split('T')[0];
                if (!acc[dateKey]) acc[dateKey] = [];
                acc[dateKey].push(app);
                return acc;
            }, {});

            const goToPreviousWeek = () => {
                const newStart = new Date(currentWeekStart);
                newStart.setDate(newStart.getDate() - 7);
                setCurrentWeekStart(newStart);
            };

            const goToNextWeek = () => {
                const newStart = new Date(currentWeekStart);
                newStart.setDate(newStart.getDate() + 7);
                setCurrentWeekStart(newStart);
            };

            const goToCurrentWeek = () => {
                setCurrentWeekStart(getWeekStart(new Date()));
            };

            // 火曜から月曜までの7日間を生成
            const weekDays = [];
            for (let i = 0; i < 7; i++) {
                const day = new Date(currentWeekStart);
                day.setDate(day.getDate() + i);
                weekDays.push(day);
            }

            return (
                <div className="container mx-auto p-4 sm:p-6 lg:p-8">
                    <header className="mb-8">
                        <button onClick={onBack} className="flex items-center text-slate-600 hover:text-slate-900 font-semibold transition mb-4">
                            <BackIcon />
                            詳細に戻る
                        </button>
                        <h1 className="text-3xl sm:text-4xl font-bold text-slate-800">{salesPerson}さんの週間アポイント</h1>
                        <div className="flex items-center justify-between mt-4">
                            <p className="text-slate-500">{formatWeekRange(currentWeekStart)}</p>
                            <div className="flex space-x-2">
                                <button onClick={goToPreviousWeek} className="px-3 py-1 bg-slate-200 text-slate-700 rounded-lg hover:bg-slate-300 transition">← 前週</button>
                                <button onClick={goToCurrentWeek} className="px-3 py-1 bg-sky-600 text-white rounded-lg hover:bg-sky-700 transition">今週</button>
                                <button onClick={goToNextWeek} className="px-3 py-1 bg-slate-200 text-slate-700 rounded-lg hover:bg-slate-300 transition">次週 →</button>
                            </div>
                        </div>
                    </header>
                    <main>
                        <div className="space-y-6">
                            {weekDays.map(day => {
                                const dateKey = day.toISOString().split('T')[0];
                                const dayAppointments = groupedByDay[dateKey] || [];
                                const dateOptions = { month: 'long', day: 'numeric', weekday: 'long' };
                                const formattedDate = new Intl.DateTimeFormat('ja-JP', dateOptions).format(day);
                                const dateColorClass = getDateColorClass(day);
                                const isToday = day.toDateString() === new Date().toDateString();

                                return (
                                    <section key={dateKey} className={`bg-white rounded-xl shadow-sm p-5 ${isToday ? 'ring-2 ring-sky-500' : ''}`}>
                                        <h2 className={`text-lg font-bold mb-3 pb-2 border-b ${dateColorClass}`}>
                                            {formattedDate}
                                            {isToday && <span className="ml-2 text-sm bg-sky-600 text-white px-2 py-1 rounded">今日</span>}
                                            <span className="text-sm font-medium text-slate-500 ml-3">({dayAppointments.length}件)</span>
                                        </h2>
                                        {dayAppointments.length > 0 ? (
                                            <div className="space-y-3">
                                                {dayAppointments.map(app => (
                                                    <AppointmentCard key={app.id} app={app} onEdit={onEdit} onDelete={onDelete} isDetailPage={true} />
                                                ))}
                                            </div>
                                        ) : (
                                            <p className="text-slate-400 text-sm py-4">アポイントはありません</p>
                                        )}
                                    </section>
                                );
                            })}
                        </div>
                    </main>
                </div>
            );
        };

        const PastAppointmentsPage = ({ appointments, onBack, onEdit, onDelete, title, filterPerson = null }) => {
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);

            const pastAppointments = appointments
                .filter(app => {
                    const isPast = app.visitStartTimestamp.toDate() <= oneHourAgo;
                    const personMatch = !filterPerson || app.salesPerson === filterPerson;
                    return isPast && personMatch;
                })
                .sort((a, b) => b.visitStartTimestamp.seconds - a.visitStartTimestamp.seconds);

            return (
                <div className="container mx-auto p-4 sm:p-6 lg:p-8">
                    <header className="mb-8">
                        <button onClick={onBack} className="flex items-center text-slate-600 hover:text-slate-900 font-semibold transition mb-4">
                            <BackIcon />
                            戻る
                        </button>
                        <h1 className="text-3xl sm:text-4xl font-bold text-slate-800">{title}</h1>
                        <p className="text-slate-500 mt-2">{pastAppointments.length}件の記録があります</p>
                    </header>
                    <main>
                        {pastAppointments.length > 0 ? (
                            <div className="space-y-5">
                                {pastAppointments.map(app => (
                                    <AppointmentCard key={app.id} app={app} onEdit={onEdit} onDelete={onDelete} isDetailPage={true} isPast={true} />
                                ))}
                            </div>
                        ) : (
                            <div className="text-center py-16 bg-white rounded-xl shadow-sm">
                                <p className="text-slate-500">過去のアポイントはありません。</p>
                            </div>
                        )}
                    </main>
                </div>
            );
        };

        // --- Main App Component ---
        function App() {
            const [db, setDb] = useState(null);
            const [auth, setAuth] = useState(null);
            const [user, setUser] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [teamId, setTeamId] = useState('');
            const [appointments, setAppointments] = useState([]);
            const [filteredAppointments, setFilteredAppointments] = useState([]);
            const [isLoading, setIsLoading] = useState(true);
            const [customerName, setCustomerName] = useState('');
            const [contactPerson, setContactPerson] = useState('');
            const [address, setAddress] = useState('');
            const [visitDate, setVisitDate] = useState('');
            const [visitStartTime, setVisitStartTime] = useState('');
            const [visitEndTime, setVisitEndTime] = useState('');
            const [purpose, setPurpose] = useState('');
            const [salesPerson, setSalesPerson] = useState('');
            const [editingId, setEditingId] = useState(null);
            const formRef = useRef(null);
            const [filterDate, setFilterDate] = useState('');
            const [filterSalesPerson, setFilterSalesPerson] = useState('');
            const [uniqueSalesPeople, setUniqueSalesPeople] = useState([]);
            const [registeredSalesPeople, setRegisteredSalesPeople] = useState([]);
            const [isModalOpen, setIsModalOpen] = useState(false);
            const [modalMessage, setModalMessage] = useState('');
            const [pendingAppointment, setPendingAppointment] = useState(null);
            const [view, setView] = useState('main');
            const [selectedSalesPerson, setSelectedSalesPerson] = useState(null);
            const [isAddressModalOpen, setIsAddressModalOpen] = useState(false);
            const [isSalesPersonModalOpen, setIsSalesPersonModalOpen] = useState(false);
            const [viewHistory, setViewHistory] = useState(['main']);

            // ブラウザの戻るボタン対応
            const viewHistoryRef = useRef(viewHistory);
            
            useEffect(() => {
                viewHistoryRef.current = viewHistory;
            }, [viewHistory]);

            useEffect(() => {
                const handlePopState = (e) => {
                    e.preventDefault();
                    const currentHistory = viewHistoryRef.current;
                    if (currentHistory.length > 1) {
                        const newHistory = [...currentHistory];
                        newHistory.pop();
                        const previousView = newHistory[newHistory.length - 1];
                        setViewHistory(newHistory);
                        setView(previousView);
                    }
                };

                window.addEventListener('popstate', handlePopState);
                
                // 初回のみhistoryにpushする
                if (window.history.state === null) {
                    window.history.pushState({ view: 'main' }, '');
                }

                return () => {
                    window.removeEventListener('popstate', handlePopState);
                };
            }, []); // 依存配列を空にして初回のみ実行

            const navigateToView = (newView, person = null) => {
                setView(newView);
                if (person) setSelectedSalesPerson(person);
                setViewHistory([...viewHistory, newView]);
                window.history.pushState({ view: newView }, '');
            };

            const navigateBack = () => {
                if (viewHistory.length > 1) {
                    const newHistory = [...viewHistory];
                    newHistory.pop();
                    const previousView = newHistory[newHistory.length - 1];
                    setViewHistory(newHistory);
                    setView(previousView);
                    window.history.back();
                }
            };

            useEffect(() => {
                const savedTeamId = localStorage.getItem('sales-app-team-id');
                if (savedTeamId) setTeamId(savedTeamId);
            }, []);

            useEffect(() => {
                const app = initializeApp(firebaseConfig);
                const authInstance = getAuth(app);
                const dbInstance = getFirestore(app);
                setAuth(authInstance);
                setDb(dbInstance);
                const unsubscribeAuth = onAuthStateChanged(authInstance, async (currentUser) => {
                    if (!currentUser) {
                        try {
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await signInWithCustomToken(authInstance, __initial_auth_token);
                            } else {
                                await signInAnonymously(authInstance);
                            }
                        } catch (error) { console.error("Authentication failed:", error); }
                    }
                    setUser(authInstance.currentUser);
                    setIsAuthReady(true);
                });
                return () => unsubscribeAuth();
            }, []);

            // 担当者リストの購読
            useEffect(() => {
                if (!isAuthReady || !db || !teamId) return;
                
                const salesPeopleDocRef = doc(db, `teams/${teamId}/settings/salespeople`);
                const unsubscribe = onSnapshot(salesPeopleDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        setRegisteredSalesPeople(data.people || []);
                    } else {
                        setRegisteredSalesPeople([]);
                    }
                }, (error) => {
                    console.error("Error fetching sales people:", error);
                    setRegisteredSalesPeople([]);
                });
                
                return () => unsubscribe();
            }, [isAuthReady, db, teamId]);

            useEffect(() => {
                if (!isAuthReady || !db || !teamId) return;
                setIsLoading(true);
                const appointmentsCollection = collection(db, `teams/${teamId}/appointments`);
                const q = query(appointmentsCollection, orderBy('visitStartTimestamp', 'asc'));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const appointmentsData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setAppointments(appointmentsData);
                    const salesPeople = [...new Set(appointmentsData.map(app => app.salesPerson).filter(Boolean))];
                    setUniqueSalesPeople(salesPeople);
                    setIsLoading(false);
                }, (error) => {
                    console.error("Error fetching appointments:", error);
                    setIsLoading(false);
                });
                return () => unsubscribe();
            }, [isAuthReady, db, teamId]);

            useEffect(() => {
                const now = new Date();
                const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);

                setFilteredAppointments(
                    appointments.filter(app => {
                        const isCurrent = app.visitStartTimestamp?.toDate() > oneHourAgo;
                        const dateMatch = !filterDate || (app.visitStartTimestamp?.toDate().toISOString().split('T')[0] === filterDate);
                        const personMatch = !filterSalesPerson || app.salesPerson === filterSalesPerson;
                        return isCurrent && dateMatch && personMatch;
                    })
                );
            }, [appointments, filterDate, filterSalesPerson]);

            const handleTeamIdSubmit = (id) => {
                localStorage.setItem('sales-app-team-id', id);
                setTeamId(id);
            };

            const handleChangeTeamId = () => {
                if (window.confirm('チームIDを変更しますか？\n（入力中の内容は失われます）')) {
                    localStorage.removeItem('sales-app-team-id');
                    setTeamId('');
                    resetForm();
                }
            };

            const handleAddSalesPerson = async (name) => {
                if (!teamId || !db) return;
                if (registeredSalesPeople.includes(name)) {
                    alert('この担当者は既に登録されています。');
                    return;
                }
                try {
                    const salesPeopleDocRef = doc(db, `teams/${teamId}/settings/salespeople`);
                    await setDoc(salesPeopleDocRef, {
                        people: [...registeredSalesPeople, name],
                        updatedAt: serverTimestamp()
                    });
                } catch (error) {
                    console.error("Error adding sales person:", error);
                    alert('担当者の追加中にエラーが発生しました。');
                }
            };

            const handleDeleteSalesPerson = async (name) => {
                if (!teamId || !db) return;
                
                const hasAppointments = appointments.some(app => app.salesPerson === name);
                if (hasAppointments) {
                    alert('この担当者にはアポイントが登録されているため削除できません。');
                    return;
                }

                if (!window.confirm(`${name}さんを削除してもよろしいですか？`)) return;

                try {
                    const salesPeopleDocRef = doc(db, `teams/${teamId}/settings/salespeople`);
                    await setDoc(salesPeopleDocRef, {
                        people: registeredSalesPeople.filter(p => p !== name),
                        updatedAt: serverTimestamp()
                    });
                } catch (error) {
                    console.error("Error deleting sales person:", error);
                    alert('担当者の削除中にエラーが発生しました。');
                }
            };

            const proceedWithSubmission = async (appointmentData) => {
                if (!teamId) return;
                try {
                    const appointmentsCollection = collection(db, `teams/${teamId}/appointments`);
                    if (editingId) {
                        const docRef = doc(db, `teams/${teamId}/appointments/${editingId}`);
                        await updateDoc(docRef, appointmentData);
                    } else {
                        await addDoc(appointmentsCollection, appointmentData);
                    }
                    resetForm();
                } catch (error) { console.error("Error saving appointment: ", error); alert('アポイントの保存中にエラーが発生しました。'); }
            };

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (!customerName || !visitDate || !visitStartTime || !purpose || !salesPerson) {
                    alert('必須項目（お名前、訪問日、開始時間、目的、営業担当）を入力してください。');
                    return;
                }
                const newStartTimestamp = new Date(`${visitDate}T${visitStartTime}`);
                const newEndTimestamp = visitEndTime ? new Date(`${visitDate}T${visitEndTime}`) : newStartTimestamp;
                const conflictingAppointment = appointments.find(app => {
                    if (editingId && app.id === editingId) return false;
                    if (app.salesPerson !== salesPerson) return false;
                    const existingStart = app.visitStartTimestamp.toDate();
                    const existingEnd = app.visitEndTimestamp ? app.visitEndTimestamp.toDate() : existingStart;
                    return newStartTimestamp < existingEnd && newEndTimestamp > existingStart;
                });
                const appointmentData = { customerName, contactPerson, address, visitStartTimestamp: newStartTimestamp, visitEndTimestamp: visitEndTime ? new Date(`${visitDate}T${visitEndTime}`) : null, purpose, salesPerson, authorId: user?.uid, createdAt: serverTimestamp() };
                if (conflictingAppointment) {
                    const { date, time } = formatVisitTime(conflictingAppointment.visitStartTimestamp, conflictingAppointment.visitEndTimestamp);
                    const message = `警告：${salesPerson}さんには、同じ日時に別のアポイントが登録されています。\n\n` + `お客様: ${conflictingAppointment.customerName} 様\n` + `日時: ${date} ${time}`;
                    setModalMessage(message);
                    setPendingAppointment(appointmentData);
                    setIsModalOpen(true);
                } else {
                    await proceedWithSubmission(appointmentData);
                }
            };

            const handleConfirmSubmit = async () => {
                if (pendingAppointment) await proceedWithSubmission(pendingAppointment);
                setIsModalOpen(false);
                setPendingAppointment(null);
            };

            const handleCancelSubmit = () => {
                setIsModalOpen(false);
                setPendingAppointment(null);
            };

            const handleEdit = (appointment) => {
                const toDateInputFormat = (date) => {
                    const year = date.getFullYear();
                    const month = ('0' + (date.getMonth() + 1)).slice(-2);
                    const day = ('0' + date.getDate()).slice(-2);
                    return `${year}-${month}-${day}`;
                };
                const toTimeInputFormat = (date) => `${('0'+date.getHours()).slice(-2)}:${('0'+date.getMinutes()).slice(-2)}`;
                
                setView('main');
                setViewHistory(['main']);
                setTimeout(() => {
                    setEditingId(appointment.id);
                    setCustomerName(appointment.customerName);
                    setContactPerson(appointment.contactPerson || '');
                    setAddress(appointment.address || '');
                    const startDate = appointment.visitStartTimestamp.toDate();
                    setVisitDate(toDateInputFormat(startDate));
                    setVisitStartTime(toTimeInputFormat(startDate));
                    setVisitEndTime(appointment.visitEndTimestamp ? toTimeInputFormat(appointment.visitEndTimestamp.toDate()) : '');
                    setPurpose(appointment.purpose);
                    setSalesPerson(appointment.salesPerson);
                    formRef.current?.scrollIntoView({ behavior: 'smooth' });
                }, 0);
            };

            const handleDelete = async (id) => {
                if (window.confirm('このアポイントを削除してもよろしいですか？')) {
                    try {
                        const docRef = doc(db, `teams/${teamId}/appointments/${id}`);
                        await deleteDoc(docRef);
                    } catch (error) { console.error("Error deleting appointment: ", error); alert('アポイントの削除中にエラーが発生しました。'); }
                }
            };

            const resetForm = () => {
                setCustomerName(''); setContactPerson(''); setAddress('');
                setVisitDate(''); setVisitStartTime(''); setVisitEndTime('');
                setPurpose(''); setSalesPerson(''); setEditingId(null);
            };
            
            const handleViewDetails = (person) => {
                navigateToView('detail', person);
            };

            const handleAddressSelect = (selectedAddress) => {
                setAddress(selectedAddress);
                setIsAddressModalOpen(false);
            };

            if (!teamId) return <TeamIdEntry onTeamIdSubmit={handleTeamIdSubmit} />;

            const mainView = (
                <div className="container mx-auto p-4 sm:p-6 lg:p-8">
                    <header className="text-center mb-10 relative">
                        <h1 className="text-4xl sm:text-5xl font-extrabold text-slate-800">アポイント共有</h1>
                        <p className="text-slate-500 mt-2">チームID: <span className="font-semibold text-sky-600">{teamId}</span></p>
                        <div className="absolute top-0 right-0 flex space-x-2">
                            <button onClick={() => setIsSalesPersonModalOpen(true)} className="p-2 text-slate-500 hover:text-sky-600 transition" title="担当者管理">
                                <SettingsIcon />
                            </button>
                            <button onClick={handleChangeTeamId} className="text-xs text-slate-500 hover:text-sky-600 underline">ID変更</button>
                        </div>
                    </header>
                    <main className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                        <div ref={formRef} className="lg:col-span-1 bg-white p-6 rounded-2xl shadow-lg h-fit">
                            <h2 className="text-2xl font-bold mb-6 border-b border-slate-200 pb-4">{editingId ? 'アポイント編集' : '新規アポイント登録'}</h2>
                            <form onSubmit={handleSubmit} className="space-y-5">
                                <div><label htmlFor="customerName" className="block text-sm font-semibold text-slate-700 mb-1">お名前 <span className="text-rose-500">*</span></label><input type="text" id="customerName" value={customerName} onChange={(e) => setCustomerName(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition" required /></div>
                                <div>
                                    <label htmlFor="address" className="block text-sm font-semibold text-slate-700 mb-1">住所</label>
                                    <div className="flex space-x-2">
                                        <input type="text" id="address" value={address} onChange={(e) => setAddress(e.target.value)} className="flex-1 px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition" />
                                        <button type="button" onClick={() => setIsAddressModalOpen(true)} className="px-3 py-2 bg-sky-600 text-white rounded-lg hover:bg-sky-700 transition flex items-center" title="地図から選択">
                                            <MapIcon />
                                        </button>
                                    </div>
                                </div>
                                <div><label htmlFor="contactPerson" className="block text-sm font-semibold text-slate-700 mb-1">その他連絡先など</label><input type="text" id="contactPerson" value={contactPerson} onChange={(e) => setContactPerson(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition" /></div>
                                <div><label htmlFor="visitDate" className="block text-sm font-semibold text-slate-700 mb-1">訪問日 <span className="text-rose-500">*</span></label><input type="date" id="visitDate" value={visitDate} onChange={(e) => setVisitDate(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition" required /></div>
                                <div className="grid grid-cols-2 gap-4">
                                    <div><label htmlFor="visitStartTime" className="block text-sm font-semibold text-slate-700 mb-1">開始時間 <span className="text-rose-500">*</span></label><input type="time" id="visitStartTime" value={visitStartTime} onChange={(e) => setVisitStartTime(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition" required /></div>
                                    <div><label htmlFor="visitEndTime" className="block text-sm font-semibold text-slate-700 mb-1">終了時間</label><input type="time" id="visitEndTime" value={visitEndTime} onChange={(e) => setVisitEndTime(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition" /></div>
                                </div>
                                <div>
                                    <label htmlFor="salesPerson" className="block text-sm font-semibold text-slate-700 mb-1">営業担当 <span className="text-rose-500">*</span></label>
                                    {registeredSalesPeople.length > 0 ? (
                                        <select id="salesPerson" value={salesPerson} onChange={(e) => setSalesPerson(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition bg-white" required>
                                            <option value="">選択してください</option>
                                            {registeredSalesPeople.map(person => (
                                                <option key={person} value={person}>{person}</option>
                                            ))}
                                        </select>
                                    ) : (
                                        <div>
                                            <input type="text" id="salesPerson" value={salesPerson} onChange={(e) => setSalesPerson(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition" required />
                                            <p className="text-xs text-slate-500 mt-1">担当者管理から担当者を追加すると選択式になります</p>
                                        </div>
                                    )}
                                </div>
                                <div><label htmlFor="purpose" className="block text-sm font-semibold text-slate-700 mb-1">目的・商談内容 <span className="text-rose-500">*</span></label><textarea id="purpose" value={purpose} onChange={(e) => setPurpose(e.target.value)} rows="4" className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition" required></textarea></div>
                                <div className="flex items-center space-x-4 pt-2">
                                    <button type="submit" className="w-full bg-sky-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 transition-transform transform hover:scale-105 shadow-lg">{editingId ? '更新する' : '登録する'}</button>
                                    {editingId && (<button type="button" onClick={resetForm} className="w-full bg-slate-200 text-slate-700 font-bold py-3 px-4 rounded-lg hover:bg-slate-300 transition">キャンセル</button>)}
                                </div>
                            </form>
                        </div>
                        <div className="lg:col-span-2">
                            <div className="bg-white p-5 rounded-2xl shadow-lg mb-6">
                                <div className="flex justify-between items-center mb-4">
                                  <h3 className="text-xl font-bold text-slate-800">絞り込み</h3>
                                  <button onClick={() => navigateToView('past_all')} className="text-sm font-semibold text-sky-600 hover:text-sky-800 transition">チームの過去アポ →</button>
                                </div>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 items-end">
                                    <div><label htmlFor="filterDate" className="block text-sm font-medium text-slate-700 mb-1">訪問日</label><input type="date" id="filterDate" value={filterDate} onChange={e => setFilterDate(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition"/></div>
                                    <div><label htmlFor="filterSalesPerson" className="block text-sm font-medium text-slate-700 mb-1">営業担当</label><select id="filterSalesPerson" value={filterSalesPerson} onChange={e => setFilterSalesPerson(e.target.value)} className="w-full px-3 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 transition bg-white"><option value="">すべての担当者</option>{uniqueSalesPeople.map(person => <option key={person} value={person}>{person}</option>)}</select></div>
                                </div>
                                <button onClick={() => {setFilterDate(''); setFilterSalesPerson('');}} className="mt-4 text-sm bg-slate-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-slate-600 transition">絞り込みをクリア</button>
                            </div>
                            <div className="space-y-5">
                                {isLoading ? (<div className="text-center py-10"><p className="text-slate-500">データを読み込み中...</p></div>) : 
                                filteredAppointments.length === 0 ? (<div className="text-center py-16 bg-white rounded-xl shadow-sm"><p className="text-slate-500">現在のアポイントはありません。</p><p className="text-slate-400 text-sm mt-2">新しいアポイントを登録してください。</p></div>) : 
                                (filteredAppointments.map(app => (<AppointmentCard key={app.id} app={app} onEdit={handleEdit} onDelete={handleDelete} onViewDetails={handleViewDetails} />)))}
                            </div>
                        </div>
                    </main>
                </div>
            );

            return (
                <div className="bg-slate-50 min-h-screen font-sans text-slate-800">
                    <ConfirmationModal isOpen={isModalOpen} message={modalMessage} onConfirm={handleConfirmSubmit} onCancel={handleCancelSubmit} />
                    <AddressModal isOpen={isAddressModalOpen} onSelect={handleAddressSelect} onCancel={() => setIsAddressModalOpen(false)} />
                    <SalesPersonManagementModal 
                        isOpen={isSalesPersonModalOpen} 
                        salesPeople={registeredSalesPeople}
                        onAdd={handleAddSalesPerson}
                        onDelete={handleDeleteSalesPerson}
                        onClose={() => setIsSalesPersonModalOpen(false)}
                    />
                    {view === 'main' && mainView}
                    {view === 'detail' && <DetailPage salesPerson={selectedSalesPerson} appointments={appointments} onBack={navigateBack} onEdit={handleEdit} onDelete={handleDelete} onViewPast={() => navigateToView('past_personal')} onViewWeekly={() => navigateToView('weekly')} />}
                    {view === 'weekly' && <WeeklyViewPage salesPerson={selectedSalesPerson} appointments={appointments} onBack={navigateBack} onEdit={handleEdit} onDelete={handleDelete} />}
                    {view === 'past_all' && <PastAppointmentsPage appointments={appointments} onBack={navigateBack} onEdit={handleEdit} onDelete={handleDelete} title="チームの過去アポイント" />}
                    {view === 'past_personal' && <PastAppointmentsPage appointments={appointments} onBack={navigateBack} onEdit={handleEdit} onDelete={handleDelete} title={`${selectedSalesPerson}さんの過去アポイント`} filterPerson={selectedSalesPerson} />}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js').then(registration => {
            console.log('ServiceWorker is registered successfully!');
          }).catch(err => {
            console.log('ServiceWorker registration failed: ', err);
          });
        });
      }
    </script>

</body>
</html>
